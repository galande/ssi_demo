"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdJwtVcService = void 0;
const core_1 = require("@sd-jwt/core");
const decode_1 = require("@sd-jwt/decode");
const utils_1 = require("@sd-jwt/utils");
const tsyringe_1 = require("tsyringe");
const crypto_1 = require("../../crypto");
const utils_2 = require("../../utils");
const dids_1 = require("../dids");
const SdJwtVcError_1 = require("./SdJwtVcError");
const repository_1 = require("./repository");
/**
 * @internal
 */
let SdJwtVcService = class SdJwtVcService {
    constructor(sdJwtVcRepository) {
        this.sdJwtVcRepository = sdJwtVcRepository;
    }
    async sign(agentContext, options) {
        var _a;
        const { payload, disclosureFrame, hashingAlgorithm } = options;
        // default is sha-256
        if (hashingAlgorithm && hashingAlgorithm !== 'sha-256') {
            throw new SdJwtVcError_1.SdJwtVcError(`Unsupported hashing algorithm used: ${hashingAlgorithm}`);
        }
        const issuer = await this.extractKeyFromIssuer(agentContext, options.issuer);
        const holderBinding = await this.extractKeyFromHolderBinding(agentContext, options.holder);
        const header = {
            alg: issuer.alg,
            typ: 'vc+sd-jwt',
            kid: issuer.kid,
        };
        const sdjwt = new core_1.SDJwtInstance({
            hasher: this.hasher,
            signer: this.signer(agentContext, issuer.key),
            hashAlg: 'sha-256',
            signAlg: issuer.alg,
            saltGenerator: agentContext.wallet.generateNonce,
        });
        const compact = await sdjwt.issue(Object.assign(Object.assign({}, payload), { cnf: holderBinding.cnf, iss: issuer.iss, iat: Math.floor(new Date().getTime() / 1000) }), disclosureFrame, { header });
        const prettyClaims = (await sdjwt.getClaims(compact));
        const a = await sdjwt.decode(compact);
        const sdjwtPayload = (_a = a.jwt) === null || _a === void 0 ? void 0 : _a.payload;
        if (!sdjwtPayload) {
            throw new SdJwtVcError_1.SdJwtVcError('Invalid sd-jwt-vc state.');
        }
        return {
            compact,
            prettyClaims,
            header: header,
            payload: sdjwtPayload,
        };
    }
    fromCompact(compactSdJwtVc) {
        // NOTE: we use decodeSdJwtSync so we can make this method sync
        const { jwt, disclosures } = (0, decode_1.decodeSdJwtSync)(compactSdJwtVc, this.hasher);
        const prettyClaims = (0, decode_1.getClaimsSync)(jwt.payload, disclosures, this.hasher);
        return {
            compact: compactSdJwtVc,
            header: jwt.header,
            payload: jwt.payload,
            prettyClaims: prettyClaims,
        };
    }
    async present(agentContext, { compactSdJwtVc, presentationFrame, verifierMetadata }) {
        const sdjwt = new core_1.SDJwtInstance({
            hasher: this.hasher,
        });
        const sdJwtVc = await sdjwt.decode(compactSdJwtVc);
        const holder = await this.extractKeyFromHolderBinding(agentContext, this.parseHolderBindingFromCredential(sdJwtVc));
        sdjwt.config({
            kbSigner: this.signer(agentContext, holder.key),
            kbSignAlg: holder.alg,
        });
        const compactDerivedSdJwtVc = await sdjwt.present(compactSdJwtVc, presentationFrame, {
            kb: {
                payload: {
                    iat: verifierMetadata.issuedAt,
                    nonce: verifierMetadata.nonce,
                    aud: verifierMetadata.audience,
                },
            },
        });
        return compactDerivedSdJwtVc;
    }
    async verify(agentContext, { compactSdJwtVc, keyBinding, requiredClaimKeys }) {
        const sdjwt = new core_1.SDJwtInstance({
            hasher: this.hasher,
        });
        const sdJwtVc = await sdjwt.decode(compactSdJwtVc);
        if (!sdJwtVc.jwt) {
            throw new SdJwtVcError_1.SdJwtVcError('Invalid sd-jwt-vc state.');
        }
        const issuer = await this.extractKeyFromIssuer(agentContext, this.parseIssuerFromCredential(sdJwtVc));
        const holder = await this.extractKeyFromHolderBinding(agentContext, this.parseHolderBindingFromCredential(sdJwtVc));
        sdjwt.config({
            verifier: this.verifier(agentContext, issuer.key),
            kbVerifier: this.verifier(agentContext, holder.key),
        });
        const verificationResult = {
            isValid: false,
            isSignatureValid: false,
        };
        await sdjwt.verify(compactSdJwtVc, requiredClaimKeys, !!keyBinding);
        verificationResult.isValid = true;
        verificationResult.isSignatureValid = true;
        verificationResult.areRequiredClaimsIncluded = true;
        // If keyBinding is present, verify the key binding
        try {
            if (keyBinding) {
                if (!sdJwtVc.kbJwt || !sdJwtVc.kbJwt.payload) {
                    throw new SdJwtVcError_1.SdJwtVcError('Keybinding is required for verification of the sd-jwt-vc');
                }
                // Assert `aud` and `nonce` claims
                if (sdJwtVc.kbJwt.payload.aud !== keyBinding.audience) {
                    throw new SdJwtVcError_1.SdJwtVcError('The key binding JWT does not contain the expected audience');
                }
                if (sdJwtVc.kbJwt.payload.nonce !== keyBinding.nonce) {
                    throw new SdJwtVcError_1.SdJwtVcError('The key binding JWT does not contain the expected nonce');
                }
                verificationResult.isKeyBindingValid = true;
                verificationResult.containsExpectedKeyBinding = true;
                verificationResult.containsRequiredVcProperties = true;
            }
        }
        catch (error) {
            verificationResult.isKeyBindingValid = false;
            verificationResult.isValid = false;
        }
        return {
            verification: verificationResult,
            sdJwtVc: {
                payload: sdJwtVc.jwt.payload,
                header: sdJwtVc.jwt.header,
                compact: compactSdJwtVc,
                prettyClaims: await sdJwtVc.getClaims(this.hasher),
            },
        };
    }
    async store(agentContext, compactSdJwtVc) {
        const sdJwtVcRecord = new repository_1.SdJwtVcRecord({
            compactSdJwtVc,
        });
        await this.sdJwtVcRepository.save(agentContext, sdJwtVcRecord);
        return sdJwtVcRecord;
    }
    async getById(agentContext, id) {
        return await this.sdJwtVcRepository.getById(agentContext, id);
    }
    async getAll(agentContext) {
        return await this.sdJwtVcRepository.getAll(agentContext);
    }
    async findByQuery(agentContext, query) {
        return await this.sdJwtVcRepository.findByQuery(agentContext, query);
    }
    async deleteById(agentContext, id) {
        await this.sdJwtVcRepository.deleteById(agentContext, id);
    }
    async update(agentContext, sdJwtVcRecord) {
        await this.sdJwtVcRepository.update(agentContext, sdJwtVcRecord);
    }
    async resolveDidUrl(agentContext, didUrl) {
        const didResolver = agentContext.dependencyManager.resolve(dids_1.DidResolverService);
        const didDocument = await didResolver.resolveDidDocument(agentContext, didUrl);
        return {
            verificationMethod: didDocument.dereferenceKey(didUrl, ['assertionMethod']),
            didDocument,
        };
    }
    get hasher() {
        return utils_2.Hasher.hash;
    }
    /**
     * @todo validate the JWT header (alg)
     */
    signer(agentContext, key) {
        return async (input) => {
            const signedBuffer = await agentContext.wallet.sign({ key, data: utils_2.TypedArrayEncoder.fromString(input) });
            return (0, utils_1.uint8ArrayToBase64Url)(signedBuffer);
        };
    }
    /**
     * @todo validate the JWT header (alg)
     */
    verifier(agentContext, key) {
        return async (message, signatureBase64Url) => {
            if (!key) {
                throw new SdJwtVcError_1.SdJwtVcError('The public key used to verify the signature is missing');
            }
            return await agentContext.wallet.verify({
                signature: utils_2.TypedArrayEncoder.fromBase64(signatureBase64Url),
                key,
                data: utils_2.TypedArrayEncoder.fromString(message),
            });
        };
    }
    async extractKeyFromIssuer(agentContext, issuer) {
        if (issuer.method === 'did') {
            const parsedDid = (0, dids_1.parseDid)(issuer.didUrl);
            if (!parsedDid.fragment) {
                throw new SdJwtVcError_1.SdJwtVcError(`didUrl '${issuer.didUrl}' does not contain a '#'. Unable to derive key from did document`);
            }
            const { verificationMethod } = await this.resolveDidUrl(agentContext, issuer.didUrl);
            const key = (0, dids_1.getKeyFromVerificationMethod)(verificationMethod);
            const alg = (0, crypto_1.getJwkFromKey)(key).supportedSignatureAlgorithms[0];
            return {
                alg,
                key,
                iss: parsedDid.did,
                kid: `#${parsedDid.fragment}`,
            };
        }
        throw new SdJwtVcError_1.SdJwtVcError("Unsupported credential issuer. Only 'did' is supported at the moment.");
    }
    parseIssuerFromCredential(sdJwtVc) {
        var _a, _b, _c;
        if (!((_a = sdJwtVc.jwt) === null || _a === void 0 ? void 0 : _a.payload)) {
            throw new SdJwtVcError_1.SdJwtVcError('Credential not exist');
        }
        if (!((_b = sdJwtVc.jwt) === null || _b === void 0 ? void 0 : _b.payload['iss'])) {
            throw new SdJwtVcError_1.SdJwtVcError('Credential does not contain an issuer');
        }
        const iss = sdJwtVc.jwt.payload['iss'];
        if (iss.startsWith('did:')) {
            // If `did` is used, we require a relative KID to be present to identify
            // the key used by issuer to sign the sd-jwt-vc
            if (!((_c = sdJwtVc.jwt) === null || _c === void 0 ? void 0 : _c.header)) {
                throw new SdJwtVcError_1.SdJwtVcError('Credential does not contain a header');
            }
            if (!sdJwtVc.jwt.header['kid']) {
                throw new SdJwtVcError_1.SdJwtVcError('Credential does not contain a kid in the header');
            }
            const issuerKid = sdJwtVc.jwt.header['kid'];
            let didUrl;
            if (issuerKid.startsWith('#')) {
                didUrl = `${iss}${issuerKid}`;
            }
            else if (issuerKid.startsWith('did:')) {
                const didFromKid = (0, dids_1.parseDid)(issuerKid);
                if (didFromKid.did !== iss) {
                    throw new SdJwtVcError_1.SdJwtVcError(`kid in header is an absolute DID URL, but the did (${didFromKid.did}) does not match with the 'iss' did (${iss})`);
                }
                didUrl = issuerKid;
            }
            else {
                throw new SdJwtVcError_1.SdJwtVcError('Invalid issuer kid for did. Only absolute or relative (starting with #) did urls are supported.');
            }
            return {
                method: 'did',
                didUrl,
            };
        }
        throw new SdJwtVcError_1.SdJwtVcError("Unsupported 'iss' value. Only did is supported at the moment.");
    }
    parseHolderBindingFromCredential(sdJwtVc) {
        var _a, _b;
        if (!((_a = sdJwtVc.jwt) === null || _a === void 0 ? void 0 : _a.payload)) {
            throw new SdJwtVcError_1.SdJwtVcError('Credential not exist');
        }
        if (!((_b = sdJwtVc.jwt) === null || _b === void 0 ? void 0 : _b.payload['cnf'])) {
            throw new SdJwtVcError_1.SdJwtVcError('Credential does not contain a holder binding');
        }
        const cnf = sdJwtVc.jwt.payload['cnf'];
        if (cnf.jwk) {
            return {
                method: 'jwk',
                jwk: cnf.jwk,
            };
        }
        else if (cnf.kid) {
            if (!cnf.kid.startsWith('did:') || !cnf.kid.includes('#')) {
                throw new SdJwtVcError_1.SdJwtVcError('Invalid holder kid for did. Only absolute KIDs for cnf are supported');
            }
            return {
                method: 'did',
                didUrl: cnf.kid,
            };
        }
        throw new SdJwtVcError_1.SdJwtVcError("Unsupported credential holder binding. Only 'did' and 'jwk' are supported at the moment.");
    }
    async extractKeyFromHolderBinding(agentContext, holder) {
        if (holder.method === 'did') {
            const parsedDid = (0, dids_1.parseDid)(holder.didUrl);
            if (!parsedDid.fragment) {
                throw new SdJwtVcError_1.SdJwtVcError(`didUrl '${holder.didUrl}' does not contain a '#'. Unable to derive key from did document`);
            }
            const { verificationMethod } = await this.resolveDidUrl(agentContext, holder.didUrl);
            const key = (0, dids_1.getKeyFromVerificationMethod)(verificationMethod);
            const alg = (0, crypto_1.getJwkFromKey)(key).supportedSignatureAlgorithms[0];
            return {
                alg,
                key,
                cnf: {
                    // We need to include the whole didUrl here, otherwise the verifier
                    // won't know which did it is associated with
                    kid: holder.didUrl,
                },
            };
        }
        else if (holder.method === 'jwk') {
            const jwk = holder.jwk instanceof crypto_1.Jwk ? holder.jwk : (0, crypto_1.getJwkFromJson)(holder.jwk);
            const key = jwk.key;
            const alg = jwk.supportedSignatureAlgorithms[0];
            return {
                alg,
                key,
                cnf: {
                    jwk: jwk.toJson(),
                },
            };
        }
        throw new SdJwtVcError_1.SdJwtVcError("Unsupported credential holder binding. Only 'did' and 'jwk' are supported at the moment.");
    }
};
SdJwtVcService = __decorate([
    (0, tsyringe_1.injectable)(),
    __metadata("design:paramtypes", [repository_1.SdJwtVcRepository])
], SdJwtVcService);
exports.SdJwtVcService = SdJwtVcService;
//# sourceMappingURL=SdJwtVcService.js.map